### *leetcode: 1~5*
---
#### *Problem 1: Two Sum*
*Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.*

*Example:*
```
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

+ 方法一： **暴力求解**,时间复杂度*O(n\*n)*;空间复杂度*O(1)*。两层`for`遍历数组元素，依次遍历元素i的同时，查找位于当前元素之后的j元素是否与当前元素的和满足条件，如果满足则返回；若遍历完所有元素没有找到解，抛出异常。

```java
	public int[] twoSum(int[] nums, int target) {
	    for (int i = 0; i < nums.length; i++) {
	        for (int j = i + 1; j < nums.length; j++) {
	            if (nums[j] == target - nums[i]) {
	                return new int[] { i, j }; // 找到解，返回
	            }
	        }
	    }
	    throw new IllegalArgumentException("No solution.");
	}
```

+ 方法二： **一次遍历哈希表**的方法，遍历数组的时间复杂度*O(n)*,哈希表查找值时间复杂度为*O(1)*，故时间复杂度为*O(n)*;遍历数组元素的同时，将已遍历元素及其索引作为键值对放到*HashMap*中，若数组中存在一组解为`nums[i]`和`nums[j]`,假定*i < j*,则必然可在遍历到元素`nums[j]`时从*HashMap*中找到`nums[i]`。

```java
    public int[] twoSum(int[] nums, int target) { 
        Map<Integer,Integer> m = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            int comp = target - nums[i];
            if(m.containsKey(comp)){
                return new int[] {m.get(comp), i};
            }
            m.put(nums[i], i); // 将元素值-索引作为键值对放到HashMap中。
        }
        throw new IllegalArgumentException("No solution.");
    }
```
