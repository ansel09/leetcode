### *leetcode: 1~5*
---
#### *Problem 1: Two Sum*
*Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.*

*Example:*
```
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

+ 方法一： **暴力求解**,时间复杂度*O(n\*n)*;空间复杂度*O(1)*。两层`for`遍历数组元素，依次遍历元素i的同时，查找位于当前元素之后的j元素是否与当前元素的和满足条件，如果满足则返回；若遍历完所有元素没有找到解，抛出异常。

```java
	public int[] twoSum(int[] nums, int target) {
	    for (int i = 0; i < nums.length; i++) {
	        for (int j = i + 1; j < nums.length; j++) {
	            if (nums[j] == target - nums[i]) {
	                return new int[] { i, j }; // 找到解，返回
	            }
	        }
	    }
	    throw new IllegalArgumentException("No solution.");
	}
```

+ 方法二： **一次遍历哈希表**的方法，遍历数组的时间复杂度*O(n)*,哈希表查找值时间复杂度为*O(1)*，故时间复杂度为*O(n)*;遍历数组元素的同时，将已遍历元素及其索引作为键值对放到*HashMap*中，若数组中存在一组解为`nums[i]`和`nums[j]`,假定*i < j*,则必然可在遍历到元素`nums[j]`时从*HashMap*中找到`nums[i]`。

```java
    public int[] twoSum(int[] nums, int target) { 
        Map<Integer,Integer> m = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            int comp = target - nums[i];
            if(m.containsKey(comp)){
                return new int[] {m.get(comp), i};
            }
            m.put(nums[i], i); // 将元素值-索引作为键值对放到HashMap中。
        }
        throw new IllegalArgumentException("No solution.");
    }
```

#### *Problem 2: Add Two Numbers*
*You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.*

*Example:*
```
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
+ 遍历链表`l1`和`l2`的元素,对于每一位需要考虑三部分：来自`l1`的元素、`l2`的元素和前一位的进位`flag`，考虑到有进位时前面所述三者和最大时为9+9+1=19，故`flag`取值只能为0和1。

```java
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) { 
        int flag = 0;
        ListNode retNode = new ListNode(0);
        ListNode currNode = retNode;
        while(l1 != null || l2 != null || flag == 1){
            int a = (l1 != null) ? l1.val : 0;
            int b = (l2 != null) ? l2.val : 0;
            int sum = a + b + flag; // 当前位需要考虑三部分
            flag = sum / 10;  // 进位
            currNode.next = new ListNode(sum % 10); // 当前位的值
            currNode = currNode.next;
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return retNode.next; // 返回链表head
    }
```
#### *Problem 3: Longest Substring Without Repeating Characters*
*Given a string, find the length of the longest substring without repeating characters.*
*Example 1:*
```
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", which the length is 3.
```
*Example 2:*
```
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```
*Example 3:*
```
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
```             
+ 无重复字符的最长子串：遍历元素时,使用一个`HashMap`保存组成无重复字符的最长子串的字符。利用`HashMap`中`put`方法的特点，当放到`HashMap`一个*key-value*键值对时，若之前存在这个`key`,新`value`会替换`oldvalue`,并且返回`oldvalue`；因此在字符遍历过程中将字符串字符做`key`,字符在字符串的位置作为`value`放到`HashMap`中,当放一个*K-V*键值队`char - i`返回的`oldindex`不为`null`且不等于正在遍历的字符的索引*i*,那么说明此前'HashMap'中存在一个字符`ch`,故将已存在`HashMap`中`value`值为`oldindex`所表示位置之前的值删掉，并判断是否更新最大无重复子串长度`maxLen`。代码如下：
```java
    public int lengthOfLongestSubstring(String s) {
        int maxLen = 0;
        HashMap<String, Integer> m = new HashMap();
        for (int i = 0; i < s.length(); i++) {
            String curr = String.valueOf(s.charAt(i));
            Integer oldIndex = m.put(curr, i);
            if (oldIndex != null && oldIndex != i) {
                for (int j = i - m.size(); j < oldIndex; j++) { // 重复时，从HashMap中清除oldIndex所示位置之前的value
                    String del = String.valueOf(s.charAt(j));
                    m.remove(del, j); 
                }
            }
            if (m.size() > maxLen) maxLen = m.size(); // 更新所保持的最大长度值
        }
        return maxLen;        
    }
```